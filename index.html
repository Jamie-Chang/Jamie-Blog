<!DOCTYPE html>
<html lang="en">
        <head>
                        <meta charset="utf-8" />
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        <meta name="generator" content="Pelican" />
                        <title>Jamie's Blog</title>
                        <link rel="stylesheet" href="./theme/css/main.css" />
                                <link href="https://blog.changs.co.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Jamie's Blog Atom Feed" />
                        <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "0358c4be608641c1ad90cd87801da29b"}'></script><!-- End Cloudflare Web Analytics -->
        </head>

        <body id="index" class="home">
                <header id="banner" class="body">
                        <h1><a href="./">Jamie's Blog</a></h1>
                        <nav><ul>
                                                <li><a href="./category/blog.html">Blog</a></li>
                        </ul></nav>
                </header><!-- /#banner -->

                <aside id="featured" class="body">
                    <article>
                        <h1 class="entry-title"><a href="./asyncio-is-neither-fast-nor-slow.html">Asyncio is neither fast nor slow</a></h1>
<footer class="post-info">
        <abbr class="published" title="2026-01-12T00:00:00+00:00">
                Published: Mon 12 January 2026
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info --><p><strong><em>Don't listen to random benchmarks..</em></strong></p>
<p>I recently came across an <a href="https://hackeryarn.com/post/async-python-benchmarks/">article</a> benchmarking Python performances in web frameworks, comparing asyncio and sync performance. </p>
<p>The author sets out to measure performance of <a href="https://fastapi.tiangolo.com/">FastAPI</a>/<a href="https://www.djangoproject.com/">Django</a> web servers running with postgresql comparing async and non-async workloads. The methodology is pretty reasonable, the following is his result for an endpoint with a single postgres database read:</p>
<table>
<thead>
<tr>
<th>Server type</th>
<th>workers</th>
<th>RPS</th>
<th>Latency avg</th>
<th>Latency max</th>
<th>Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sync Django</td>
<td>1</td>
<td>456</td>
<td>140ms</td>
<td>262ms</td>
<td>153ms</td>
</tr>
<tr>
<td>Sync Django</td>
<td>2</td>
<td>669</td>
<td>96ms</td>
<td>262ms</td>
<td>132ms</td>
</tr>
<tr>
<td>Sync Django Pooled</td>
<td>1</td>
<td>569</td>
<td>112ms</td>
<td>171ms</td>
<td>117ms</td>
</tr>
<tr>
<td>Sync Django Pooled</td>
<td>2</td>
<td>1822</td>
<td>35ms</td>
<td>98ms</td>
<td>50ms</td>
</tr>
<tr>
<td>Async Django</td>
<td>1</td>
<td>205</td>
<td>312ms</td>
<td>467ms</td>
<td>331ms</td>
</tr>
<tr>
<td>Async Django</td>
<td>2</td>
<td>541</td>
<td>118ms</td>
<td>304ms</td>
<td>196ms</td>
</tr>
<tr>
<td>FastAPI</td>
<td>1</td>
<td>236</td>
<td>271ms</td>
<td>372ms</td>
<td>287ms</td>
</tr>
<tr>
<td>FastAPI</td>
<td>2</td>
<td>409</td>
<td>156ms</td>
<td>433ms</td>
<td>224ms</td>
</tr>
</tbody>
</table>
<p>As a result the author concludes:</p>
<blockquote>
<p>These benchmarks show just how much optimization for sync web services Django and the Python has. Sync Django Pooled outperforms or matches all other configurations. Even FastAPI only performs better when it‚Äôs the sole bottleneck.</p>
</blockquote>
<p>When I read these result I had some doubts, I noticed that:  </p>
<p>1.‚Å† ‚Å†it shows that the best sync django scenario with 2 workers, has more than 4x throughput that the equivalent fastapi async solution.
2.‚Å† ‚Å†2 workers of sync django pooled is 3x the performance of a single worker.</p>
<p>The former doesn't line with the my personal experience. Asyncio does add overhead in some cases, but the scenario laid out here should have postgres as the bottleneck. Overhead caused by asyncio's event loop shouldn't be significant. </p>
<p>The latter also seemed a little odd, as the throughput increase should be proportional to the number of workers.</p>
<h3>Reviewing the code</h3>
<p>Since the results don't match my own expectation then either my mental model is wrong or it's the benchmark. So let's review the benchmark code.</p>
<p>The code for the fastapi endpoint is as follows:</p>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;/quote&quot;</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">quote</span><span class="p">(</span><span class="n">db</span><span class="p">:</span> <span class="n">AsyncSession</span> <span class="o">=</span> <span class="n">Depends</span><span class="p">(</span><span class="n">get_db</span><span class="p">)):</span>
    <span class="n">statement</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">select</span><span class="p">(</span><span class="n">Quote</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">random</span><span class="p">())</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">Quote</span><span class="o">.</span><span class="n">author</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span>
    <span class="n">quote</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;quote&quot;</span><span class="p">:</span> <span class="n">quote</span><span class="o">.</span><span class="n">quote_text</span><span class="p">,</span>
        <span class="s2">&quot;author&quot;</span><span class="p">:</span> <span class="n">quote</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
    <span class="p">}</span>
</code></pre></div>

<p>Here a single random quote is fetched from the table. <a href="https://www.sqlalchemy.org/">SQLAlchemy</a> is used as an orm to facilitate query building. Everything seems in order.</p>
<p>But wait, there's a subtle problem here! By default <a href="https://www.sqlalchemy.org/">SQLAlchemy</a> does not batch results, instead it will fetch all results into memory first when ‚Å† execute ‚Å† is called. So whilst ‚Å† <code>.scalar()</code> ‚Å†only returns the first result, in the background all results are fetched.</p>
<h3>Recreating the benchmark</h3>
<p>So I recreated the benchmark with my code fix for fastapi.</p>
<div class="highlight"><pre><span></span><code><span class="n">statement</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">Quote</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">random</span><span class="p">())</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">Quote</span><span class="o">.</span><span class="n">author</span><span class="p">))</span>
<span class="p">)</span>
</code></pre></div>

<p>I tried where possible to keep the same code and parameters to the original. </p>
<p>‚Ä¢‚Å†  ‚Å†Hardware: Macbook Pro M3 11 cores 18 GB of RAM
‚Ä¢‚Å†  ‚Å†Connection Pool Configuration: min 5 - max 15 connections
‚Ä¢‚Å†  ‚Å†Data: 100 authors with 1000 quotes
‚Ä¢‚Å†  ‚Å†Benchmark: ‚Å†‚ÄØrewrk -d 30s -c 64 --host http://localhost:8000/quote/‚ÄØ‚Å†</p>
<h3>Results</h3>
<p>And the results are as follows:</p>
<table>
<thead>
<tr>
<th>Server type</th>
<th>workers</th>
<th>RPS</th>
<th>Latency avg</th>
<th>Latency max</th>
<th>Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sync Django</td>
<td>1</td>
<td>341.81</td>
<td>186.61ms</td>
<td>418.90ms</td>
<td>223.96ms</td>
</tr>
<tr>
<td>Sync Django</td>
<td>2</td>
<td>338.74</td>
<td>188.07ms</td>
<td>467.42ms</td>
<td>227.23ms</td>
</tr>
<tr>
<td>Sync Django Pooled</td>
<td>1</td>
<td>440.46</td>
<td>144.92ms</td>
<td>281.12ms</td>
<td>150.94ms</td>
</tr>
<tr>
<td>Sync Django Pooled</td>
<td>2</td>
<td>419.01</td>
<td>152.30ms</td>
<td>374.59ms</td>
<td>167.25ms</td>
</tr>
<tr>
<td>Async Django</td>
<td>1</td>
<td>323.32</td>
<td>197.28ms</td>
<td>497.76ms</td>
<td>249.85ms</td>
</tr>
<tr>
<td>Async Django</td>
<td>2</td>
<td>322.78</td>
<td>197.45ms</td>
<td>453.63ms</td>
<td>249.18ms</td>
</tr>
<tr>
<td>FastAPI</td>
<td>1</td>
<td>687.26</td>
<td>92.95ms</td>
<td>326.49ms</td>
<td>110.29ms</td>
</tr>
<tr>
<td>FastAPI</td>
<td>2</td>
<td>673.85</td>
<td>94.78ms</td>
<td>332.11ms</td>
<td>121.00ms</td>
</tr>
</tbody>
</table>
<p>As expected the FastAPI implementation does a lot better here compared to before. Performing better than the best django version. </p>
<p>What's weird is that the worker count makes very little difference in the performance, often slowing down rather than speeding up. My guess is that my setup has more rows in the database, therefore we reach a saturation point a lot quicker.</p>
<h3>The dilemma of benchmarks</h3>
<p>Still you might be a bit disappointed with this benchmark as I was, the original had a much clearer trend between async/sync worker count and pooled database connections. However this is precisely what happens with these "real world" benchmarks. Here we're trying to represent a real use case, not necessarily to prove a point. </p>
<p>On the other hand, there exist many micro-benchmarks out there, where variables are controlled and a smaller more predictable scenario is measured.</p>
<p>There are places for both types of benchmarks, real world benchmarks can be more interesting but the data is messy and requires more critical analysis.</p>
<h3>Critical analysis</h3>
<p>My results are convenient for my beliefs and one might conclude from it that asyncio is indeed much faster. </p>
<p>But looking at the numbers I wondered why Django is so much slower, where does the slow down actually come from. I expected asyncio to do quite well but I assumed we can make up the performance with more threads or workers, but that does not seem to be the case.</p>
<p>This lead me into a deep dive, trying almost every combination of configuration, implementation and framework. </p>
<p>First I wanted more control over the variables, <a href="https://www.djangoproject.com/">Django</a> is a very different framework compared to <a href="https://fastapi.tiangolo.com/">FastAPI</a> and a there are too many possibilities when it comes to the performance discrepancy. <a href="https://flask.palletsprojects.com/">Flask</a> is a lighter weight framework compared to <a href="https://www.djangoproject.com/">Django</a> as such it is a much better sync vs async comparison.</p>
<p>Secondly, the original benchmark makes a point of the benefits of pooled connections. However, async django can also benefit from pooled connections. <a href="https://www.sqlalchemy.org/">Sqlalchemy</a> also uses a connection pool by default. So I see no reason to not use connection pools across the board.</p>
<h3>The new results</h3>
<p>This time around I decided to run different thread and worker configurations through the gauntlet and only keep the best performing configurations.</p>
<p>This was generally 3 workers and 5 threads on my machine, giving me a total of 15 threads. However other configurations with similar total thread counts also performed very similarly. </p>
<table>
<thead>
<tr>
<th>Server type</th>
<th>workers</th>
<th>threads</th>
<th>RPS</th>
<th>Latency avg</th>
<th>Latency max</th>
<th>Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>FastAPI (Pooled)</td>
<td>1</td>
<td>-</td>
<td>687.26</td>
<td>92.95ms</td>
<td>326.49ms</td>
<td>110.29ms</td>
</tr>
<tr>
<td>Flask (Pooled)</td>
<td>3</td>
<td>5</td>
<td>682.73</td>
<td>93.66ms</td>
<td>239.67ms</td>
<td>104.34ms</td>
</tr>
<tr>
<td>Django (Pooled)</td>
<td>3</td>
<td>5</td>
<td>411.91</td>
<td>155.17ms</td>
<td>299.19ms</td>
<td>169.44ms</td>
</tr>
<tr>
<td>Django Async (Pooled)</td>
<td>1</td>
<td>-</td>
<td>406.90</td>
<td>152.79ms</td>
<td>279.93ms</td>
<td>160.32ms</td>
</tr>
</tbody>
</table>
<blockquote>
<p>NOTE: asgi for the async frameworks don't use threads</p>
</blockquote>
<p>And this time, the results are more even with the fastapi implementation pulling a little ahead over flask, though over many different runs the results are practically identical. </p>
<p>This is more an expected result, as once again the main bottleneck is the database and not the web framework. </p>
<p>These results show that there is no significant difference between the django implementations. The original discrepancies are easily explained by the the connection pooling.</p>
<p>The only thing that doesn't make sense to me is why django is slower than the flask implementation all else being equal. </p>
<h3>Digging even deeper</h3>
<p>My immediate thought was skill issues, I don't have a lot of experiences with django and it's possible I made a mistake that lead to performance degradation. Checking the code and the orm generated SQL query, nothing really stood out. Then I confirmed that the database driver we're using is indeed psycopg 3 so no differences there.</p>
<p>Finally, I decided to give a closer look at the connection pool used in django, and that's where it all clicked. django uses <a href="https://www.psycopg.org/psycopg3/docs/basic/pool.html">psycopg_pool</a> an implementation provided directly by <a href="https://www.psycopg.org/">psycopg</a>. Where as sqlalchemy has its own implementation. The differences are actually significant, </p>
<ul>
<li>sqlalchemy has a lazy pool implementation, which means that connections are created or destroyed only when the pool is being accessed.</li>
<li>‚Å†On the other hand, psycopg-pool actively maintains the pool and processes tasks using background thread workers.</li>
</ul>
<p>So one more time, I modified my fastapi and flask implementation to use the same connection pool as Django:</p>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;/quote/&quot;</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">quote</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">PlainTextResponse</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">pool</span><span class="o">.</span><span class="n">connection</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span> <span class="k">as</span> <span class="n">cur</span><span class="p">:</span>

            <span class="k">await</span> <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
                <span class="s2">&quot;SELECT q.id, q.quote_text, a.name FROM quotes_quote q &quot;</span>
                <span class="s2">&quot;JOIN quotes_author a ON q.author_id = a.id &quot;</span>
                <span class="s2">&quot;ORDER BY RANDOM() LIMIT 1&quot;</span>
            <span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="k">await</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">PlainTextResponse</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">--</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>And I got the following results:</p>
<table>
<thead>
<tr>
<th>Server type</th>
<th>workers</th>
<th>threads</th>
<th>RPS</th>
<th>Latency avg</th>
<th>Latency max</th>
<th>Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>FastAPI</td>
<td>1</td>
<td>-</td>
<td>687.26</td>
<td>92.95ms</td>
<td>326.49ms</td>
<td>110.29ms</td>
</tr>
<tr>
<td>FastAPI (psycopg_pool)</td>
<td>1</td>
<td>-</td>
<td>526.21</td>
<td>121.49ms</td>
<td>248.73ms</td>
<td>128.85ms</td>
</tr>
<tr>
<td>Flask</td>
<td>3</td>
<td>5</td>
<td>682.73</td>
<td>93.66ms</td>
<td>239.67ms</td>
<td>104.34ms</td>
</tr>
<tr>
<td>Flask (psycopg_pool)</td>
<td>3</td>
<td>5</td>
<td>532.82</td>
<td>119.95ms</td>
<td>289.91ms</td>
<td>172.75ms</td>
</tr>
<tr>
<td>Django</td>
<td>3</td>
<td>5</td>
<td>411.91</td>
<td>155.17ms</td>
<td>299.19ms</td>
<td>169.44ms</td>
</tr>
<tr>
<td>Django Async</td>
<td>1</td>
<td>-</td>
<td>406.90</td>
<td>152.79ms</td>
<td>279.93ms</td>
<td>160.32ms</td>
</tr>
</tbody>
</table>
<p>So it's quite clear here that <a href="https://www.psycopg.org/psycopg3/docs/basic/pool.html">psycopg_pool</a> is the root cause in this particularly scenario.</p>
<p>There is still some differences between django and the other frameworks, but I think that's likely because we're using raw sql queries over django's orm. </p>
<h3>Conclusion</h3>
<p>If you were hoping for an answer of "just use async" or "don't use async", life is not so simple. The lesson I hope you take is that there are nuances when it comes to this topic. </p>
<p>Time and time again there's been posts on async performances, and we often see misleading benchmarks or analysis. </p>
<p>Let's sum up my own thoughts:</p>
<ul>
<li>Asyncio's advantage has never been speed in particular, but the cost. We can achieve the same performance with no added threads or processes.</li>
<li>Even then you might consider using django or other sync frameworks if you're more familiar with them or if they provide something you don't get elsewhere, e.g. django's rich middleware plugin system.</li>
<li>Benchmarks cannot be taken at face value, try to reproduce it for your requirements (LLMs are pretty good at this).</li>
<li>Lastly when you get a result from a benchmark that doesn't match expectation, it's prudent that you investigate where the discrepancy comes from.</li>
</ul>
<h3>Future Steps</h3>
<p>This whole exercise, as exhausting as it is, barely scratches the itch. There's quite a few unexplored questions:</p>
<ul>
<li>What is the advantage of <a href="https://www.psycopg.org/psycopg3/docs/basic/pool.html"><code>psycopg_pool</code></a>'s implementation, are there cases where it performs better?</li>
<li>Are there any configuration or ticks I'm missing to speed up <a href="https://www.djangoproject.com/">Django</a>?</li>
<li>There's not a lot of analysis on async django as it uses threads to run database queries and middlewares, but I think it's worth looking at which situations where async django wins.</li>
<li>Is there a general rule for thread/process numbers that maximise the performances and what are the trade offs of having more threads.</li>
</ul>
<p>In the near future I intend to put together a more comprehensive comparison of different concurrency models and explore these questions.</p>
<p>The best I could do right now is to provide the full <a href="https://github.com/Jamie-Chang/web-async-benchmark">source code</a> and hopefully encourage people to make their own measurements and share their results. In case there's been any mistakes the feedback is very much welcome there.</p>                    </article>
                </aside><!-- /#featured -->
                    <section id="content" class="body">
                        <h1>Other articles</h1>
                        <hr />
                        <ol id="posts-list" class="hfeed">

                <li><article class="hentry">
                    <header>
                        <h1><a href="./i-was-wrong-about-subinterpreters.html" rel="bookmark"
                               title="Permalink to I was wrong about Subinterpreters">I was wrong about Subinterpreters</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2026-01-01T00:00:00+00:00">
                Published: Thu 01 January 2026
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
<p>tags: <a href="./tag/python.html">Python</a> <a href="./tag/pthon.html">œÄthon</a> <a href="./tag/python314.html">Python3.14</a> <a href="./tag/subinterpreters.html">Subinterpreters</a> </p>        
</footer><!-- /.post-info -->                        <p><strong><em>... but that's actually a good thing</em></strong></p>
<p>I've already written a ton about subinterpreters since a year ago:  </p>
<ul>
<li><a href="./how-good-are-sub-interpreters-in-python-now.html">How good are sub-interpreters in Python now?</a></li>
<li><a href="./python-314-state-of-free-threading.html">Python 3.14: State of free threading</a></li>
<li><a href="./subinterpreters-and-asyncio.html">Subinterpreters and Asyncio</a></li>
</ul>
<p>Recently I had some time to dig a bit deeper into subinterpreters and check my understanding ‚Ä¶</p>
                        <a class="readmore" href="./i-was-wrong-about-subinterpreters.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./trying-out-marimo-notebooks.html" rel="bookmark"
                               title="Permalink to Trying out marimo notebooks">Trying out marimo notebooks</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-12-03T00:00:00+00:00">
                Published: Wed 03 December 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->                        <p>As we approach the holiday seasons, we get to "enjoy" another 12 days of <a href="https://adventofcode.com/">Advent of Code</a>. Every year I try to do something a little different, last year I had a lot of fun solving it in Ocaml, prior years I've tried the latest Python features. This year I've ‚Ä¶</p>
                        <a class="readmore" href="./trying-out-marimo-notebooks.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./fixing-lazy-imports-generating-static-types-dynamically.html" rel="bookmark"
                               title="Permalink to Fixing lazy imports: Generating Static Types Dynamically">Fixing lazy imports: Generating Static Types Dynamically</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-10-29T00:00:00+00:00">
                Published: Wed 29 October 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->                        <p>So I've just released a package called <a href="https://pypi.org/project/lazy-helper/">lazy-helper</a>. This comes as lazy loading has been a hot topic once again due to the proposal <a href="https://peps.python.org/pep-0810/">PEP-810</a>.</p>
<p>Using my package we can define lazy loaded dependencies nicely:</p>
<p><img alt="Defining a lazy module" src="./images/lazypy.png"></p>
<p>Coincidentally Brian Okken has recently written a <a href="https://pythontest.com/polite-lazy-imports-python-packages/">blog post</a> covering the topic of lazy loading ‚Ä¶</p>
                        <a class="readmore" href="./fixing-lazy-imports-generating-static-types-dynamically.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./python-314-3-asyncio-changes.html" rel="bookmark"
                               title="Permalink to Python 3.14: 3 Asyncio Changes">Python 3.14: 3 Asyncio Changes</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-10-09T00:00:00+01:00">
                Published: Thu 09 October 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
<p>tags: <a href="./tag/python.html">Python</a> <a href="./tag/pthon.html">œÄthon</a> <a href="./tag/python314.html">Python3.14</a> <a href="./tag/asyncio.html">asyncio</a> </p>        
</footer><!-- /.post-info -->                        <p>Python 3.14 was officially released on October 7th. There are a lot of new features and I've covered some of them before in:</p>
<ul>
<li><a href="./python-314-3-smaller-features.html">Python 3.14: 3 smaller features</a></li>
<li><a href="./t-strings-the-good-and-the-ugly.html">t-strings: the good and the ugly</a></li>
<li><a href="./subinterpreters-and-asyncio.html">Subinterpreters and Asyncio</a></li>
</ul>
<p>What I haven't covered here are any of the asyncio changes ‚Ä¶</p>
                        <a class="readmore" href="./python-314-3-asyncio-changes.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./finally-trying-out-mojo.html" rel="bookmark"
                               title="Permalink to Finally trying out Mojo üî•">Finally trying out Mojo üî•</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-10-02T00:00:00+01:00">
                Published: Thu 02 October 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
<p>tags: <a href="./tag/mojo.html">Mojo</a> <a href="./tag/python.html">Python</a> <a href="./tag/advent-of-code.html">Advent of Code</a> </p>        
</footer><!-- /.post-info -->                        <p><a href="https://www.modular.com/mojo">Mojo</a> has been on my radar for a while. In fact, I heard about it on launch back in May 2023. It was touted as a super set of Python with 10000s of times the performance. It's main focus is on AI related workloads with strong built in support of ‚Ä¶</p>
                        <a class="readmore" href="./finally-trying-out-mojo.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./blog-1-year-in.html" rel="bookmark"
                               title="Permalink to Blog 1 year in">Blog 1 year in</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-09-24T00:00:00+01:00">
                Published: Wed 24 September 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->                        <p>It's been just over a year since I started my blog. In fact, this is my 27th blog post. I thought it'd be a good time for me to share some insights on blogging.</p>
<h3>Motivation</h3>
<p>Recently I've been asked by some people on why I do this. I think for ‚Ä¶</p>
                        <a class="readmore" href="./blog-1-year-in.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./asyncio-backpressure-follow-up.html" rel="bookmark"
                               title="Permalink to Asyncio backpressure - follow up">Asyncio backpressure - follow up</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-09-14T00:00:00+01:00">
                Published: Sun 14 September 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->                        <p>Previously when discussing <a href="./asyncio-backpressure-processing-lots-of-tasks-in-parallel.html">asyncio backpressure</a> I've made some claims that were not necessarily complete.</p>
<p>I said:</p>
<blockquote>
<p>It works well for 100s of urls but when we hit a big number like 10000s we have a problem.</p>
<p>The program seemingly hangs. This is because all the tasks are being created first ‚Ä¶</p></blockquote>
                        <a class="readmore" href="./asyncio-backpressure-follow-up.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./simplify-lambda-deployments-with-uv.html" rel="bookmark"
                               title="Permalink to Simplify lambda deployments with UV">Simplify lambda deployments with UV</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-09-01T00:00:00+01:00">
                Published: Mon 01 September 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->                        <p>The python packaging landscape and developer experience has shifted dramatically in the past year or so with <a href="https://docs.astral.sh/uv/">uv</a>'s launch marked a pivotal moment. But behind the scenes many PEPs have worked to get us to this point. </p>
<p>One such PEP was <a href="https://peps.python.org/pep-0723/">PEP 723 ‚Äì Inline script metadata</a> which we discussed ‚Ä¶</p>
                        <a class="readmore" href="./simplify-lambda-deployments-with-uv.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./dynamic-config-part-1-pydantic-and-file-watchers.html" rel="bookmark"
                               title="Permalink to Dynamic config part 1: Pydantic and file watchers">Dynamic config part 1: Pydantic and file watchers</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-08-26T00:00:00+01:00">
                Published: Tue 26 August 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->                        <p>Feature flags or dynamic configuration is something that I find very useful, however I've never had the chance to use them. This is for a lack of options <a href="https://launchdarkly.com/">launchdarkly</a>, <a href="https://www.flagsmith.com/">flagsmith</a> and <a href="https://www.getunleash.io/">unleash</a> to name a few. </p>
<p>SaaS options can be amazing with a full array of features, but I would ‚Ä¶</p>
                        <a class="readmore" href="./dynamic-config-part-1-pydantic-and-file-watchers.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>
                    </ol><!-- /#posts-list -->
  <nav>
    <ul>
      <li>Page 1 / 4</li>
        <li><a href="./index2.html">&rang;</a></li>
        <li><a href="./index4.html">&Rang;</a></li>
    </ul>
  </nav>
                    </section><!-- /#content -->
                <section id="extras" class="body">
                                <div class="social">
                                        <h2>social</h2>
                                        <ul>
                                                        <li><a href="https://blog.changs.co.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                                                        <li><a href="https://github.com/Jamie-Chang/">Github</a></li>
                                                        <li><a href="https://www.linkedin.com/in/jamie-chang-4423ba125/">LinkedIn</a></li>
                                                        <li><a href="https://bsky.app/profile/changs.co.uk/">Bluesky</a></li>
                                        </ul>
                                </div><!-- /.social -->
                </section><!-- /#extras -->

                <footer id="contentinfo" class="body">
                        <address id="about" class="vcard body">
                                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                        </address><!-- /#about -->

                        <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
                </footer><!-- /#contentinfo -->

        </body>
</html>