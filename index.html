<!DOCTYPE html>
<html lang="en">
        <head>
                        <meta charset="utf-8" />
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        <meta name="generator" content="Pelican" />
                        <title>Jamie's Blog</title>
                        <link rel="stylesheet" href="./theme/css/main.css" />
                                <link href="https://blog.changs.co.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Jamie's Blog Atom Feed" />
        </head>

        <body id="index" class="home">
                <header id="banner" class="body">
                        <h1><a href="./">Jamie's Blog</a></h1>
                        <nav><ul>
                                                <li><a href="./category/blog.html">Blog</a></li>
                        </ul></nav>
                </header><!-- /#banner -->

                <aside id="featured" class="body">
                    <article>
                        <h1 class="entry-title"><a href="./closing-python-iterators.html">Closing Python Iterators</a></h1>
<footer class="post-info">
        <abbr class="published" title="2024-09-28T00:00:00+01:00">
                Published: Sat 28 September 2024
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info --><p>I recently came across a <a href="https://youtu.be/N56Jrqc7SBk?si=6WmYrq8C4E-gwn4_">video</a> by mcoding about Python iterators' unfortunate closing behaviour.</p>
<p>To sum up the video, when an iterator is interrupted we intuitively we would expect the exit of a context manager or a finally block to be called but that's not <strong>necessarily</strong> the case. For example,</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generator_with_close</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Closing&quot;</span><span class="p">)</span>
</code></pre></div>

<p>if we then have the following code interrupt the generator:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">generator_with_close</span><span class="p">():</span>
    <span class="k">break</span>
</code></pre></div>

<p>We actually get what we expected:</p>
<div class="highlight"><pre><span></span><code>Starting
Closing
</code></pre></div>

<p>But this is due to Python's garbage collection implicitly calling the close method on the generator.</p>
<p>And as the video pointed out, this won't work if we keep any reference to the iterator. Nor is it necessarily the case for all Python implementation that we always garbage collect immediately. </p>
<p>Additionally the asyncio version of this is even more problematic as we won't be able to run the async <code>aclose</code> during garbage collection.</p>
<p>The <a href="https://peps.python.org/pep-0533/">PEP-533</a> proposal for fixing this ultimately cannot be accepted due to backwards compatibility concerns.</p>
<h3>Calling <code>.close()</code></h3>
<p>The best way to resolve this issue is to call <code>.close()</code> explicitly. Or with <code>contextlib.closing</code>. This is guaranteed to work and be correct but places the responsibility on the caller of the generator to close the iterator. </p>
<p>The issue is, whether the iterator needs to be closed is implementation specific. So the caller either has to step into the implementation or verbosely call close for every generator.</p>
<h3>Solutions</h3>
<p>I believe there to be two correct ways to solve this issue, in lew of the PEP solution. Both method change the callee's signature to avoid any ambiguity.</p>
<h4>Option 1</h4>
<p>Never use <code>finally</code> or <code>with</code> inside generator functions.</p>
<p>This sounds pretty terrible, but in practice is probably not that big of an issue. The reasons to use <code>with</code>/<code>finally</code> tend to be for closing resources, so we can just shift where we define and close the resource:</p>
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="n">create_db</span><span class="p">()</span> <span class="k">as</span> <span class="n">db</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">query</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>
        <span class="o">...</span>
</code></pre></div>

<p>Generally, I believe this is a better pattern. We often use dependencies more than once. And this is a case where explicit is better. </p>
<h4>Option 2</h4>
<p>I will concede that not all cases are covered by Option 1. For example, I have this following snippet of code to fetch messages from a broker:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">messages</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">broker</span><span class="o">.</span><span class="n">messages</span><span class="p">():</span>
        <span class="k">with</span> <span class="n">set_context</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">message</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
</code></pre></div>

<p>I can lift <code>set_context</code> out of the generator. But it certainly makes more sense to set the id inside as the id is not needed outside.</p>
<p>So I think it's better to have an explicit way to force people to close the generator. </p>
<p>We can achieve this by converting the generator function to a contextmanager function:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ContextManager</span><span class="p">,</span> <span class="n">Generator</span> 


<span class="k">def</span> <span class="nf">contextgenerator</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">](</span><span class="n">gen</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">ContextManager</span><span class="p">[</span><span class="n">T</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps generators in a context manager.</span>

<span class="sd">    This ensures generators are closed properly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">closing_gen</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContextManager</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">closing</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">closing_gen</span>
</code></pre></div>

<p>Then we just need to wrap the generator in a <code>@contextgenerator</code> like this:</p>
<div class="highlight"><pre><span></span><code><span class="nd">@contextgenerator</span>
<span class="k">def</span> <span class="nf">messages</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div>

<p>And called this way:</p>
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="n">messages</span><span class="p">()</span> <span class="k">as</span> <span class="n">message_iterator</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">message_iterator</span><span class="p">:</span>
        <span class="o">...</span>
</code></pre></div>

<p>Here we rely on the decorator to communicate the change in signature to the end user.</p>
<p>But the type checker will also pick up the fact that <code>messages</code> now returns a context manager as opposed to an iterator.</p>
<p>The benefit here is that there is no way to start the generator without entering the context manager, thus ensuring that the generator closes.</p>
<p>The caller can choose to use this when closing behaviour is required, or use a plain generator when not.</p>
<p>For asyncio we have a similar solution:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">aclosing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">AsyncContextManager</span><span class="p">,</span> <span class="n">AsyncGenerator</span>


<span class="k">def</span> <span class="nf">asynccontextgenerator</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="n">AsyncGenerator</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">](</span><span class="n">gen</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">AsyncContextManager</span><span class="p">[</span><span class="n">T</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps generators in a context manager.</span>

<span class="sd">    This ensures generators are closed properly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">closing_gen</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncContextManager</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">aclosing</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">closing_gen</span>
</code></pre></div>

<h3>Conclusion</h3>
<p>This issue is something that would catch me out on occasion, thanks to mcoding's video I finally have a good understanding on what's going on.</p>
<p>I think in leu of a more sophisticated fix like PEP-533, we could use a combination of the two approaches I've given to mitigate the issue. This can be done by library authors or developers when defining the generators and doesn't rely on the caller to close them explicitly.</p>                    </article>
                </aside><!-- /#featured -->
                    <section id="content" class="body">
                        <h1>Other articles</h1>
                        <hr />
                        <ol id="posts-list" class="hfeed">

                <li><article class="hentry">
                    <header>
                        <h1><a href="./free-threaded-python-with-asyncio.html" rel="bookmark"
                               title="Permalink to Free Threaded Python With Asyncio">Free Threaded Python With Asyncio</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2024-09-19T00:00:00+01:00">
                Published: Thu 19 September 2024
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->                        <p>With the immanent release of Python 3.13, I wanted to look at the biggest changes coming to Python. I think by far the most exciting feature is free-threaded Python from <a href="https://peps.python.org/pep-0703/">PEP-703</a>.</p>
<p>As I'm quite late to the party, there's already a of articles talking about it. I came accross …</p>
                        <a class="readmore" href="./free-threaded-python-with-asyncio.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="./my-first-blog-post.html" rel="bookmark"
                               title="Permalink to My First Blog Post">My First Blog Post</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2024-09-18T00:00:00+01:00">
                Published: Wed 18 September 2024
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->                        <p>My name is Jamie Chang, I'm a software engineer in London. I like all things Python, but I'll try to mix it up sometimes. I decided to start this blog to get some of the ideas out from my head and to practice communicating technical topics.</p>
<p>For this site, I'm …</p>
                        <a class="readmore" href="./my-first-blog-post.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>
                    </ol><!-- /#posts-list -->
                    </section><!-- /#content -->
                <section id="extras" class="body">
                                <div class="social">
                                        <h2>social</h2>
                                        <ul>
                                                        <li><a href="https://blog.changs.co.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                                                        <li><a href="https://github.com/Jamie-Chang/">Github</a></li>
                                                        <li><a href="https://www.linkedin.com/in/jamie-chang-4423ba125/">LinkedIn</a></li>
                                        </ul>
                                </div><!-- /.social -->
                </section><!-- /#extras -->

                <footer id="contentinfo" class="body">
                        <address id="about" class="vcard body">
                                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                        </address><!-- /#about -->

                        <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
                </footer><!-- /#contentinfo -->

        </body>
</html>