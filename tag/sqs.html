<!DOCTYPE html>
<html lang="en">
        <head>
                        <meta charset="utf-8" />
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        <meta name="generator" content="Pelican" />
                        <title>Jamie's Blog - SQS</title>
                        <link rel="stylesheet" href="../theme/css/main.css" />
                                <link href="https://blog.changs.co.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Jamie's Blog Atom Feed" />
                        <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "0358c4be608641c1ad90cd87801da29b"}'></script><!-- End Cloudflare Web Analytics -->
        </head>

        <body id="index" class="home">
                <header id="banner" class="body">
                        <h1><a href="../">Jamie's Blog</a></h1>
                        <nav><ul>
                                                <li><a href="../category/blog.html">Blog</a></li>
                        </ul></nav>
                </header><!-- /#banner -->

                <aside id="featured" class="body">
                    <article>
                        <h1 class="entry-title"><a href="../writing-a-sqs-task-framework-from-scratch.html">Writing a SQS task framework from scratch</a></h1>
<footer class="post-info">
        <abbr class="published" title="2025-11-24T00:00:00+00:00">
                Published: Mon 24 November 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="../author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="../category/blog.html">Blog</a>.</p>
<p>tags: <a href="../tag/python.html">Python</a> <a href="../tag/asyncio.html">Asyncio</a> <a href="../tag/sqs.html">SQS</a> </p>        
</footer><!-- /.post-info --><p>Recently I've been working on framework to run LLM tasks using AWS's excellent <a href="https://aws.amazon.com/sqs/">SQS</a>. And I made the decision to write my own task framework/library as opposed to using a pre-exiting framework. I thought this would be a great opportunity to discuss the considerations and levels of abstractions involved when coding a framework.</p>
<h3>Why SQS?</h3>
<p>Having come from using traditional message queues like RabbitMQ, I can't help but compare SQS with RabbitMQ. The thing is, whilst they can be interchangeable. I think they are actually built with different use cases in mind.</p>
<p>RabbitMQ is for processing a large volume of messages, the messages are strictly processed in FIFO order. SQS has more flexibility around when a message is processed and how long each task takes. So RabbitMQ is good for handling events, but SQS is better for tasks like LLM calls.</p>
<p>Additionally, SQS uses http to communicate between the server and the client which is easier to monitor and is easier to setup if you already have an AWS cluster.</p>
<h3>Why not use ...?</h3>
<p>Okay so, the first question I will answer you is why not a pre-existing framework? </p>
<p>When we talk about task framework in Python, there is a general consensus. The most popular choice is <a href="https://docs.celeryq.dev/en/stable/getting-started/introduction.html">Celery</a>, a framework that can handle pretty much any handle workload in any broker (be it SQS or otherwise). If you need a UI and compose tasks in a DAG (Directed Acyclic Graph) then you should use <a href="https://airflow.apache.org/">Airflow</a>. If you like new technology and talking about orchestration then use something <a href="https://temporal.io/">temporal</a>. The list really goes on and on. </p>
<p>I haven't used a lot of managed task solutions like temporal which admittedly is something I'd love to try out.</p>
<p>As for why I don't use something like celery. Celery is a framework that tries to work with everything including all brokers. That is only true to an extent as it was originally designed to work with RabbitMQ. Generally the support is also pretty good for Redis but not so good otherwise. A lot of broker specific features are either not supported or not documented.</p>
<p>Another issue is a lack of asyncio support. For my use case asyncio is great, no need for multiple threads or processes. Celery again tries very hard to be general, it supports the concurrency paradigm most likely to support a user's code without a lot of input from the user. But in my case, I already have an opinion of how I want my code to run, and it just doesn't make sense to use it.</p>
<p>Finally, my general complaint of celery is that it requires a lot of configuration for a production use case. Which can cause quite a bit of a headache. </p>
<h2>Creating my abstractions</h2>
<p>In my experience writing a good framework is all about how good the abstractions are. Abstractions can come with a cost. Whilst Celery create abstractions that allow task compositions and provides support for many brokers, but it trades broker specific features and increases in configuration complexity.</p>
<p>Therefore a good abstraction is about making useful trade-offs. </p>
<h3>Writing the code</h3>
<p>Before we start with abstractions, it's a good idea to first write some code to see what the it currently looks like with no abstraction.</p>
<p>Here I ask a LLM to provide an example:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">aiobotocore.session</span> <span class="kn">import</span> <span class="n">get_session</span>

<span class="c1"># Replace with your actual Queue URL</span>
<span class="n">QUEUE_URL</span> <span class="o">=</span> <span class="s2">&quot;https://sqs.us-east-1.amazonaws.com/123456789012/my-queue&quot;</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">consume_messages</span><span class="p">():</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">get_session</span><span class="p">()</span>

    <span class="c1"># create_client is an async context manager that handles connection cleanup</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">create_client</span><span class="p">(</span><span class="s1">&#39;sqs&#39;</span><span class="p">,</span> <span class="n">region_name</span><span class="o">=</span><span class="s1">&#39;us-east-1&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listening for messages on </span><span class="si">{</span><span class="n">QUEUE_URL</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># receive_message calls the SQS API</span>
                <span class="c1"># WaitTimeSeconds=20 enables Long Polling (waits for messages to arrive)</span>
                <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">receive_message</span><span class="p">(</span>
                    <span class="n">QueueUrl</span><span class="o">=</span><span class="n">QUEUE_URL</span><span class="p">,</span>
                    <span class="n">MaxNumberOfMessages</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">WaitTimeSeconds</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                    <span class="n">VisibilityTimeout</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Check if &#39;Messages&#39; key exists in response</span>
                <span class="k">if</span> <span class="s1">&#39;Messages&#39;</span> <span class="ow">in</span> <span class="n">response</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">response</span><span class="p">[</span><span class="s1">&#39;Messages&#39;</span><span class="p">]:</span>
                        <span class="c1"># 1. Process the message</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received body: </span><span class="si">{</span><span class="n">msg</span><span class="p">[</span><span class="s1">&#39;Body&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                        <span class="c1"># 2. Delete the message so it isn&#39;t processed again</span>
                        <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">delete_message</span><span class="p">(</span>
                            <span class="n">QueueUrl</span><span class="o">=</span><span class="n">QUEUE_URL</span><span class="p">,</span>
                            <span class="n">ReceiptHandle</span><span class="o">=</span><span class="n">msg</span><span class="p">[</span><span class="s1">&#39;ReceiptHandle&#39;</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Message deleted.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No messages received in this poll.&quot;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error encountered: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Backoff on error</span>
</code></pre></div>

<h3>Identifying Trade-offs</h3>
<p>Next we look at things we want to change and thus the trade-offs.</p>
<p>Let's start with deleting the message, the purpose of deleting the message is to signal that the message is complete and shouldn't be processed again. I personally don't like the naming of this, in the context of message queues this is usually called <code>ack</code>. </p>
<p>Something like:</p>
<div class="highlight"><pre><span></span><code><span class="n">client</span><span class="o">.</span><span class="n">ack</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</code></pre></div>

<p>Next, let's look at some of the attributes we can abstract:</p>
<ul>
<li><code>VisibilityTimeout</code>: is the amount of time the message can be processed for before going back on the queue, it is also how we can delay the message for when adding a message to the queue. We can make this clearer by calling it keep-alive and delay respectively.</li>
<li><code>MaxNumberOfMessages</code>: is a useful feature of SQS to fetch a batch of messages at once to increase throughput and reduce the cloud bill. But it may not be a good fit for my use case handling LLM requests as they don't work well in batches</li>
<li><code>WaitTimeSeconds</code> enables long polling which reduces the number of requests and hence the cloud bill. This is a good idea to keep on. And there's no real need for us to turn it off. </li>
</ul>
<h3>Creating the client</h3>
<p>Now that the trade offs are identified, we will start to create the client code, and this is what I've come up with:</p>
<div class="highlight"><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">QueueClient</span><span class="p">:</span>
    <span class="n">client</span><span class="p">:</span> <span class="n">SQSClient</span>
    <span class="n">queue</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">poll_interval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_alive</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">ack</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">MessageTypeDef</span><span class="p">]:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">messages</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">receive_message</span><span class="p">(</span>
                <span class="n">QueueUrl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span>
                <span class="n">MaxNumberOfMessages</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">WaitTimeSeconds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">poll_interval</span><span class="p">,</span>
                <span class="n">VisibilityTimeout</span><span class="o">=</span><span class="n">keep_alive</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">match</span> <span class="n">messages</span><span class="p">:</span>
                <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;Messages&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">message</span><span class="p">]}:</span>
                    <span class="k">yield</span> <span class="n">message</span>
                    <span class="k">if</span> <span class="n">ack</span><span class="p">:</span>
                        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">ack</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">continue</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">ack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">MessageTypeDef</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">delete_message</span><span class="p">(</span>
            <span class="n">QueueUrl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span>
            <span class="n">ReceiptHandle</span><span class="o">=</span><span class="n">message</span><span class="p">[</span><span class="s2">&quot;ReceiptHandle&quot;</span><span class="p">],</span>
        <span class="p">)</span>
</code></pre></div>

<p>In order to pass the messages to the user, I've represented the stream of messages as an AsyncIterator. Iterators are truly one of Python's best features, and here it fits particularly well as are trying to expose the messages to the user without making may assumptions about how to user wants to consume it.</p>
<p>Consuming messages then is as simple as running an async for loop:</p>
<div class="highlight"><pre><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">client</span><span class="o">.</span><span class="n">consume</span><span class="p">():</span>
        <span class="k">await</span> <span class="n">handle</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</code></pre></div>                    </article>
                </aside><!-- /#featured -->
                <section id="extras" class="body">
                                <div class="social">
                                        <h2>social</h2>
                                        <ul>
                                                        <li><a href="https://blog.changs.co.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                                                        <li><a href="https://github.com/Jamie-Chang/">Github</a></li>
                                                        <li><a href="https://www.linkedin.com/in/jamie-chang-4423ba125/">LinkedIn</a></li>
                                                        <li><a href="https://bsky.app/profile/changs.co.uk/">Bluesky</a></li>
                                        </ul>
                                </div><!-- /.social -->
                </section><!-- /#extras -->

                <footer id="contentinfo" class="body">
                        <address id="about" class="vcard body">
                                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                        </address><!-- /#about -->

                        <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
                </footer><!-- /#contentinfo -->

        </body>
</html>