<!DOCTYPE html>
<html lang="en">
        <head>
                        <meta charset="utf-8" />
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        <meta name="generator" content="Pelican" />
                        <title>Subinterpreters are official!</title>
                        <link rel="stylesheet" href="./theme/css/main.css" />
                                <link href="https://blog.changs.co.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Jamie's Blog Atom Feed" />
                        <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "0358c4be608641c1ad90cd87801da29b"}'></script><!-- End Cloudflare Web Analytics -->
    <meta name="description" content="PEP-734 subinterpreters in the stdlib has officially been included in the Python 3.14 as a very late addition. If you've been following my blog..." />
        </head>

        <body id="index" class="home">
                <header id="banner" class="body">
                        <h1><a href="./">Jamie's Blog</a></h1>
                        <nav><ul>
                                                <li class="active"><a href="./category/blog.html">Blog</a></li>
                        </ul></nav>
                </header><!-- /#banner -->
  <section id="content" class="body">
    <article>
      <header>
        <h1 class="entry-title">
          <a href="./subinterpreters-are-official.html" rel="bookmark"
             title="Permalink to Subinterpreters are official!">Subinterpreters are official!</a></h1>
      </header>

      <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-08-05T00:00:00+01:00">
                Published: Tue 05 August 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="./author/jamie-chang.html">Jamie Chang</a>
                </address>
        <p>In <a href="./category/blog.html">Blog</a>.</p>
        
</footer><!-- /.post-info -->        <p><a href="https://peps.python.org/pep-0734">PEP-734</a> subinterpreters in the stdlib has officially been included in the Python 3.14 as a very late <a href="https://docs.python.org/3.14/whatsnew/3.14.html#whatsnew314-pep734">addition</a>. If you've been following my blog posts you'll know that I'm particularly excited about this feature. </p>
<h2>Quick Recap</h2>
<p>I've compared it against free-threading numerous times:</p>
<ul>
<li><a href="./how-good-are-sub-interpreters-in-python-now.html">How good are sub-interpreters in Python now?</a></li>
<li><a href="./python-314-state-of-free-threading.html">Python 3.14: State of free threading</a></li>
</ul>
<p>My little advent of code example has been my goto benchmark of parallelism in Python. And multiple interpreters have consistently beaten free-threading in performance. </p>
<p>My conclusion has been that whilst threads are familiar to most Python users, tools for memory management are limited and will come as quite a shock to Python users. On the other hand, multiple interpreters are hard to use but does offer memory management. In the end, depending on the issue subinterpreters can achieve speedups that is currently unachievable in free-threading.</p>
<h2>What's new now?</h2>
<p>subinterpreters have now been moved to a standard library module called <a href="https://docs.python.org/3.14/library/concurrent.interpreters.html">concurrent.interpreters</a> but otherwise has the same API as before.</p>
<h2>Usability</h2>
<p>I've found two simple ways to access parallelism of interpreters. </p>
<h3>InterpreterPoolExecutor</h3>
<p>The new <a href="https://docs.python.org/3.14/library/concurrent.futures.html#interpreterpoolexecutor"><code>InterpreterPoolExecutor</code></a> is similar to <code>ProcessPoolExecutor</code>. </p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">InterpreterPoolExecutor</span>


<span class="k">def</span> <span class="nf">sums</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">with</span> <span class="n">InterpreterPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sums</span><span class="p">,</span> <span class="p">[</span><span class="mi">100_000</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)))</span>
</code></pre></div>

<p>In order to pass the function itself, the arguments and return values are pickled before they are passed to the interpreters. Which will impact performance and may cancel out a lot of the performance gains over other parallelism mechanisms like free-threading and multi-processing.</p>
<p>On the other hand it's really easy to use, so it's still worth considering. </p>
<h3>Interpreter's <code>call_in_thread</code></h3>
<p><a href="https://docs.python.org/3.14/library/concurrent.interpreters.html#concurrent.interpreters.Interpreter.call_in_thread"><code>call_in_thread</code></a> will call the given function but it'll use shared memory to call the thread.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">concurrent.interpreters</span> <span class="kn">import</span> <span class="n">create</span>


<span class="k">def</span> <span class="nf">sums</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">threads</span> <span class="o">=</span> <span class="p">[</span><span class="n">create</span><span class="p">()</span><span class="o">.</span><span class="n">call_in_thread</span><span class="p">(</span><span class="n">sums</span><span class="p">,</span> <span class="mi">100_000</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></div>

<p>This will be much faster than pickling, but it's still a little awkward to use.</p>
<p>First issue is that the function does not abstract the thread creation nor does it provide any mechanism to retrieve the results.</p>
<p>The bigger issue for some of my use cases are that we're not reusing interpreters. Suppose we want to call something 1000s of times over the program's life cycle. Creating 1000s of interprets will add a lot of overhead. The usability issues here would probably lead most users to use the executor and miss out on using shared memory.</p>
<h2>My Abstraction</h2>
<p>In my previous examples, I used <code>Interpreter.exec</code> to create serval long lived interpreters with <code>Interpreter.Queue</code>s to synchronise and pass data. This was a crude attempt but worked well for my use case. </p>
<p>My goal this time is to generalise it such that:</p>
<ul>
<li>An interpreter can execute a number of different functions</li>
<li>I can integrate with asyncio, as for me personally it's my "go to" way of programming concurrently.</li>
</ul>
<h3>Architecture</h3>
<p>The architecture of the system can be represented by the following sequence diagram</p>
<p><img alt="sequence diagram" src="./images/architecture.png"></p>
<p>We spawn multiple worker(interpreter) threads and a single coordinator thread. The worker thread consume the task queue and put results on the result queue. </p>
<p>The coordinator thread then picks up the results and sets the results in the future. Any awaiting tasks on the main thread will then resolve. Here's some simplified snippet of  to give you some idea of how this looks:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Runner</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">workers</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span> <span class="o">=</span> <span class="n">create_queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="n">create_queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_code</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            while True:</span>
<span class="s2">                task = tasks.get()</span>
<span class="s2">                # run function</span>
<span class="s2">                results.put(result)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span>

    <span class="k">def</span> <span class="nf">_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">create</span><span class="p">()</span>
        <span class="n">interp</span><span class="o">.</span><span class="n">prepare_main</span><span class="p">(</span><span class="n">tasks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">)</span>
        <span class="n">interp</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_code</span><span class="p">)</span>
        <span class="n">interp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start the runner in a `with` block.</span>

<span class="sd">        This will create the workers eagerly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">threads</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_coordinator</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="o">*</span><span class="p">(</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_worker</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">)),</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_coordinator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">workers</span>
        <span class="k">while</span> <span class="n">workers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
                <span class="k">case</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Interpreter closed</span>
                    <span class="n">workers</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">case</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">reason</span><span class="p">):</span>
                    <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">future</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">InterpreterError</span><span class="p">(</span><span class="n">reason</span><span class="p">))</span>
                <span class="k">case</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="kc">True</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">other</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InterpreterError</span><span class="p">(</span><span class="s2">&quot;Unexpected queue value: &quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">run</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">id_</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
</code></pre></div>

<p>Note that the actual <a href="https://github.com/Jamie-Chang/aiointerpreters/blob/main/src/aiointerpreters/runner.py">working example</a> uses 
<code>loop.call_soon_threadsafe(...)</code> the event loop is not thread safe.</p>
<h3>Function loading</h3>
<p>Then there's the problem of loading functions into the interpreters. As far as I can tell, the best way to do so without pickle is to import the functions inside the interpreters.</p>
<p>So inside the interpreter's code, I added the following utility to load functions:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">load_entry_point</span><span class="p">(</span><span class="n">entry_point_type</span><span class="p">,</span> <span class="n">path_or_module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">entry_point_type</span> <span class="o">==</span> <span class="s2">&quot;module&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">path_or_module</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">entry_point_type</span> <span class="o">==</span> <span class="s2">&quot;path&quot;</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="s2">&quot;my_module&quot;</span><span class="p">,</span> <span class="n">path_or_module</span><span class="p">)</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span>
</code></pre></div>

<p>There are two ways to load functions, one using the module name. For example, <code>from package.sub_package.module import function</code>. The second way by the module's file path. </p>
<p>The module method is used by default as this is generally how Python will do imports. Paths are used in cases where the module in question is <code>__main__</code> which the subinterpreters will have no concept of.</p>
<h2>Example</h2>
<p>I packaged my abstractions in a package called <a href="https://github.com/Jamie-Chang/aiointerpreters">aiointerpreters</a> which is installable on pypi. To demonstrate the advantage of multiple interpreters, I created the following <a href="https://github.com/Jamie-Chang/aiointerpreters/blob/main/examples/crawl.py">crawler example</a>.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">cast</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="kn">from</span> <span class="nn">httpx</span> <span class="kn">import</span> <span class="n">AsyncClient</span>

<span class="kn">from</span> <span class="nn">aiointerpreters.runner</span> <span class="kn">import</span> <span class="n">Runner</span>

<span class="n">BASE_WIKI_URL</span> <span class="o">=</span> <span class="s2">&quot;https://en.wikipedia.org&quot;</span>
<span class="n">urls</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">content</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
    <span class="n">urls</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">urljoin</span><span class="p">(</span><span class="n">BASE_WIKI_URL</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">a_tag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;href&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">a_tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;div#bodyContent a[href]&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">)</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">}</span><span class="s2"> s elapsed&quot;</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">run_all</span><span class="p">(</span><span class="n">urls</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">timer</span><span class="p">(</span><span class="s2">&quot;ran asyncio&quot;</span><span class="p">):</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">AsyncClient</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Runner</span><span class="p">(</span><span class="n">workers</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="n">semaphore</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
                <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TaskGroup</span><span class="p">()</span> <span class="k">as</span> <span class="n">tg</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
                        <span class="k">await</span> <span class="n">semaphore</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                        <span class="n">tg</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
                            <span class="n">fetch_and_count</span><span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">url</span><span class="p">),</span>
                            <span class="n">name</span><span class="o">=</span><span class="n">url</span><span class="p">,</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">semaphore</span><span class="o">.</span><span class="n">release</span><span class="p">())</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_and_count</span><span class="p">(</span><span class="n">runner</span><span class="p">:</span> <span class="n">Runner</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">AsyncClient</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
    <span class="n">links</span> <span class="o">=</span> <span class="k">await</span> <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parse</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">url</span><span class="w"> </span><span class="si">= }</span><span class="s2"> </span><span class="si">{</span><span class="n">links</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_all</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
</code></pre></div>

<p>The crawler example loads wikipedia pages in concurrently using asyncio and then delegates the parsing task to subinterpreters. </p>
<p>This combines of asyncio's fast IO bound operations and subinterpreters parallel parsing. Using the different technologies where they are most performant. The fast communication between the main thread's event loop and interpreters means performance degradation is fairly minimal.</p>
<h2>Caveats and Next steps</h2>
<p>The biggest caveat of all this is that we can only use shareable types which are mostly immutable. This is one area that free-threading can potentially work better, though lock contention is an issue there. </p>
<p>Mutability is possible via <a href="https://docs.python.org/3/c-api/memoryview.html">memory view</a> objects, additionally I imagine we can use C to create shared mutable objects. But this is an area that needs more investigation.</p>
<p>The function loading mechanism will only work for top-level functions. This is unlikely to change as isolation is a fundamental property of interpreters. If a closure or an object method is needed we'll have to use pickling in <code>InterpreterPoolExecutor</code>.</p>
<h2>Why?</h2>
<p>I've left out the biggest question of why?. </p>
<p>I think subinterpreters are awesome, but I believe in its current form it's not very accessible. Bridging it to <code>asyncio</code> might seem strange at first but I think it's one of the easiest way to program concurrently. </p>
<p>My hope is that through <code>aiointerpreters</code> more people can quickly try this and see how much speed up they can achieve.</p>
      </div><!-- /.entry-content -->

    </article>
  </section>
                <section id="extras" class="body">
                                <div class="social">
                                        <h2>social</h2>
                                        <ul>
                                                        <li><a href="https://blog.changs.co.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                                                        <li><a href="https://github.com/Jamie-Chang/">Github</a></li>
                                                        <li><a href="https://www.linkedin.com/in/jamie-chang-4423ba125/">LinkedIn</a></li>
                                                        <li><a href="https://bsky.app/profile/jamie-chang.bsky.social/">Bluesky</a></li>
                                        </ul>
                                </div><!-- /.social -->
                </section><!-- /#extras -->

                <footer id="contentinfo" class="body">
                        <address id="about" class="vcard body">
                                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                        </address><!-- /#about -->

                        <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
                </footer><!-- /#contentinfo -->

        </body>
</html>